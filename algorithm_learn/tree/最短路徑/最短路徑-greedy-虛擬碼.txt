/*
[zj]				[Q]https://zerojudge.tw/ShowProblem?problemid=b117
[最短路徑][greedy]
*/





建立整數:ans=0		代表答案

建立vector:tre[],bktre[]		格式為tre[起點]={ {終點,邊權重},...   }

建立整數:n,m		n代表有多少個點		m代表有多少條線

建立清單lne		lne[i]代表1走到i最短有多長


主程式{
	重複執行(讀入n,m){
		將tre,bktre清空
		將lne全部設為無限(或極值)
		將ans設為0
		<讀入>
		重複m次{
			建立整數:a,b,c		a表起點		b表終點		c表長度
			讀入a,b,c
			tre[a]新增{b,c}		樹tre:a連向b 長度為c
			bktre[b]新增{a,c}		樹bktre:b連向a 長度為c
		}
		<計算解答>
		<solve>
		建立自動排序清單:que		由小排到大		每項格式為{目前走了多長,我在哪}
		新增{0,1}到que
		lne[1]=0;		表1走到1只要0單位長
		重複執行(que裡面還有東西){
			建立整數:nw
			將que最左端的資料放入nw
			如果(nw.目前走了多長 不同於 lne[nw.我在哪]){		如果現在走了多常和紀錄中不同
				跳過此次執行
			}
			ans+=lne[nw.我在哪];		答案增加lne[nw.我在哪]
			(因為這次來是最短路徑了，沒有其他更短的路了)

			對現在的點 (nw.我在哪) 在 tre 進行 廣度搜尋 ，搜尋 一 層
			並設搜尋到的點為 i ，移動到該點須走 j 單位，每次搜尋時執行{
				如果(從nw.我在哪 到 i 的總長度 會比 原本的 好){
					將此次結果更新到tre[i]		(此次結果為 從nw.我在哪 到 i 的總長度)
					新增{tre[i],i}到que
				}
			}
		}
		</solve>
		再次執行<solve>，但改在bktre進行廣度搜尋		如果只要計算去，不用回來，那不需計算此步驟
		輸出答案
	}
}

/*
[I1]
[房間數量 n] [道路數量 m]
{[點1 a] [點2 b] [邊權重 c]}*n
1<=a,b<=n
[O1]
[ans]
若可以從點1走到其他所有點再走回來
輸出最短距離
若不行則輸出0
*/

/*think*/
/*

使用類bfs和類topological sort和greedy

每次執行時都會優先拿目前路徑最短的工作
然後往下走

可以證明第一次走到該點時，工作簿上面的路徑即為最短路徑
然後我不想寫證明，有興趣的幫忙補充謝謝

如果這個工作和紀錄簿上面的"可以最短路"的長度不同
代表說這點走過了
這也可以證，但我不想證

根據上面這兩點，就可以寫出這支code了
詳細的可以直接看code，不然單靠文字是無法描述清楚的

*/
